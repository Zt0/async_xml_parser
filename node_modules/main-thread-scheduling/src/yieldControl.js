import state from './state';
import queueTask from './queueTask';
import isTimeToYield from './isTimeToYield';
import hasValidContext from './hasValidContext';
import { createTask, nextTask, removeTask } from './tasks';
import { cancelPromiseEscape, requestPromiseEscape } from './promiseEscape';
let promiseEscapeId;
/**
 * Waits for the browser to become idle again in order to resume work. Calling `yieldControl()`
 * multiple times will create a LIFO(last in, first out) queue â€“ the last call to
 * `yieldControl()` will get resolved first.
 *
 * @param priority {('user-visible' | 'background')} The priority of the task being run.
 * `user-visible` priority will always be resolved first. `background` priority will always be
 * resolved second.
 * @returns {Promise<void>} The promise that will be resolved when the queue
 */
export default async function yieldControl(priority) {
    if (!hasValidContext()) {
        return;
    }
    cancelPromiseEscape(promiseEscapeId);
    const task = createTask(priority);
    await schedule(priority);
    if (state.tasks[0] !== task) {
        await task.deferred;
        if (isTimeToYield(priority)) {
            await schedule(priority);
        }
    }
    removeTask(task);
    cancelPromiseEscape(promiseEscapeId);
    promiseEscapeId = requestPromiseEscape(() => {
        nextTask();
    });
}
async function schedule(priority) {
    var _a, _b;
    if (state.frameTimeElapsed) {
        await state.onAnimationFrame;
    }
    if (priority === 'user-visible' || typeof requestIdleCallback === 'undefined') {
        await new Promise((resolve) => queueTask(resolve));
        // istanbul ignore if
        if (((_b = (_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) === null || _b === void 0 ? void 0 : _b.call(_a)) === true) {
            await schedule(priority);
        }
        else if (state.frameWorkStartTime === undefined) {
            state.frameWorkStartTime = Date.now();
        }
    }
    else {
        await state.onIdleCallback;
        // not checking for `navigator.scheduling?.isInputPending?.()` here because idle callbacks
        // ensure no input is pending
        if (state.frameWorkStartTime === undefined) {
            state.frameWorkStartTime = Date.now();
        }
    }
}
